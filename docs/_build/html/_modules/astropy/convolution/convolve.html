
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.convolution.convolve &#8212; fermi_stacking  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for astropy.convolution.convolve</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.ctypeslib</span> <span class="kn">import</span> <span class="n">ndpointer</span><span class="p">,</span> <span class="n">load_library</span>

<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">,</span> <span class="n">MAX_NORMALIZATION</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.console</span> <span class="kn">import</span> <span class="n">human_file_size</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astropy.nddata</span> <span class="kn">import</span> <span class="n">support_nddata</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.core</span> <span class="kn">import</span> <span class="n">CompoundModel</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.core</span> <span class="kn">import</span> <span class="n">SPECIAL_OPERATORS</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.convolution</span> <span class="kn">import</span> <span class="n">Convolution</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">KernelSizeError</span><span class="p">,</span> <span class="n">has_even_axis</span><span class="p">,</span> <span class="n">raise_even_kernel_exception</span>

<span class="n">LIBRARY_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="c1"># numpy.distutils is deprecated since numpy 1.23</span>
        <span class="c1"># see https://github.com/astropy/astropy/issues/12865</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">_convolve</span> <span class="o">=</span> <span class="n">load_library</span><span class="p">(</span><span class="s2">&quot;_convolve&quot;</span><span class="p">,</span> <span class="n">LIBRARY_PATH</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Convolution C extension is missing. Try re-building astropy.&quot;</span><span class="p">)</span>

<span class="c1"># The GIL is automatically released by default when calling functions imported</span>
<span class="c1"># from libraries loaded by ctypes.cdll.LoadLibrary(&lt;path&gt;)</span>

<span class="c1"># Declare prototypes</span>
<span class="c1"># Boundary None</span>
<span class="n">_convolveNd_c</span> <span class="o">=</span> <span class="n">_convolve</span><span class="o">.</span><span class="n">convolveNd_c</span>
<span class="n">_convolveNd_c</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_convolveNd_c</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">,</span> <span class="s2">&quot;WRITEABLE&quot;</span><span class="p">}),</span>  <span class="c1"># return array</span>
                          <span class="n">ndpointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">),</span>  <span class="c1"># input array</span>
                          <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span>  <span class="c1"># N dim</span>
                          <span class="c1"># size array for input and result unless</span>
                          <span class="c1"># embed_result_within_padded_region is False,</span>
                          <span class="c1"># in which case the result array is assumed to be</span>
                          <span class="c1"># input.shape - 2*(kernel.shape//2). Note: integer division.</span>
                          <span class="n">ndpointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">),</span>
                          <span class="n">ndpointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">),</span>  <span class="c1"># kernel array</span>
                          <span class="n">ndpointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">),</span>  <span class="c1"># size array for kernel</span>
                          <span class="n">ctypes</span><span class="o">.</span><span class="n">c_bool</span><span class="p">,</span>  <span class="c1"># nan_interpolate</span>
                          <span class="n">ctypes</span><span class="o">.</span><span class="n">c_bool</span><span class="p">,</span>  <span class="c1"># embed_result_within_padded_region</span>
                          <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">]</span>  <span class="c1"># n_threads</span>

<span class="c1"># np.unique([scipy.fft.next_fast_len(i, real=True) for i in range(10000)])</span>
<span class="n">_good_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>   <span class="mi">0</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>    <span class="mi">2</span><span class="p">,</span>    <span class="mi">3</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span>    <span class="mi">5</span><span class="p">,</span>    <span class="mi">6</span><span class="p">,</span>    <span class="mi">8</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>   <span class="mi">10</span><span class="p">,</span>   <span class="mi">12</span><span class="p">,</span>  <span class="c1"># noqa E201</span>
                          <span class="mi">15</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span>   <span class="mi">18</span><span class="p">,</span>   <span class="mi">20</span><span class="p">,</span>   <span class="mi">24</span><span class="p">,</span>   <span class="mi">25</span><span class="p">,</span>   <span class="mi">27</span><span class="p">,</span>   <span class="mi">30</span><span class="p">,</span>   <span class="mi">32</span><span class="p">,</span>   <span class="mi">36</span><span class="p">,</span>   <span class="mi">40</span><span class="p">,</span>
                          <span class="mi">45</span><span class="p">,</span>   <span class="mi">48</span><span class="p">,</span>   <span class="mi">50</span><span class="p">,</span>   <span class="mi">54</span><span class="p">,</span>   <span class="mi">60</span><span class="p">,</span>   <span class="mi">64</span><span class="p">,</span>   <span class="mi">72</span><span class="p">,</span>   <span class="mi">75</span><span class="p">,</span>   <span class="mi">80</span><span class="p">,</span>   <span class="mi">81</span><span class="p">,</span>   <span class="mi">90</span><span class="p">,</span>
                          <span class="mi">96</span><span class="p">,</span>  <span class="mi">100</span><span class="p">,</span>  <span class="mi">108</span><span class="p">,</span>  <span class="mi">120</span><span class="p">,</span>  <span class="mi">125</span><span class="p">,</span>  <span class="mi">128</span><span class="p">,</span>  <span class="mi">135</span><span class="p">,</span>  <span class="mi">144</span><span class="p">,</span>  <span class="mi">150</span><span class="p">,</span>  <span class="mi">160</span><span class="p">,</span>  <span class="mi">162</span><span class="p">,</span>
                         <span class="mi">180</span><span class="p">,</span>  <span class="mi">192</span><span class="p">,</span>  <span class="mi">200</span><span class="p">,</span>  <span class="mi">216</span><span class="p">,</span>  <span class="mi">225</span><span class="p">,</span>  <span class="mi">240</span><span class="p">,</span>  <span class="mi">243</span><span class="p">,</span>  <span class="mi">250</span><span class="p">,</span>  <span class="mi">256</span><span class="p">,</span>  <span class="mi">270</span><span class="p">,</span>  <span class="mi">288</span><span class="p">,</span>
                         <span class="mi">300</span><span class="p">,</span>  <span class="mi">320</span><span class="p">,</span>  <span class="mi">324</span><span class="p">,</span>  <span class="mi">360</span><span class="p">,</span>  <span class="mi">375</span><span class="p">,</span>  <span class="mi">384</span><span class="p">,</span>  <span class="mi">400</span><span class="p">,</span>  <span class="mi">405</span><span class="p">,</span>  <span class="mi">432</span><span class="p">,</span>  <span class="mi">450</span><span class="p">,</span>  <span class="mi">480</span><span class="p">,</span>
                         <span class="mi">486</span><span class="p">,</span>  <span class="mi">500</span><span class="p">,</span>  <span class="mi">512</span><span class="p">,</span>  <span class="mi">540</span><span class="p">,</span>  <span class="mi">576</span><span class="p">,</span>  <span class="mi">600</span><span class="p">,</span>  <span class="mi">625</span><span class="p">,</span>  <span class="mi">640</span><span class="p">,</span>  <span class="mi">648</span><span class="p">,</span>  <span class="mi">675</span><span class="p">,</span>  <span class="mi">720</span><span class="p">,</span>
                         <span class="mi">729</span><span class="p">,</span>  <span class="mi">750</span><span class="p">,</span>  <span class="mi">768</span><span class="p">,</span>  <span class="mi">800</span><span class="p">,</span>  <span class="mi">810</span><span class="p">,</span>  <span class="mi">864</span><span class="p">,</span>  <span class="mi">900</span><span class="p">,</span>  <span class="mi">960</span><span class="p">,</span>  <span class="mi">972</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>
                        <span class="mi">1080</span><span class="p">,</span> <span class="mi">1125</span><span class="p">,</span> <span class="mi">1152</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">1215</span><span class="p">,</span> <span class="mi">1250</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">1296</span><span class="p">,</span> <span class="mi">1350</span><span class="p">,</span> <span class="mi">1440</span><span class="p">,</span> <span class="mi">1458</span><span class="p">,</span>
                        <span class="mi">1500</span><span class="p">,</span> <span class="mi">1536</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">1620</span><span class="p">,</span> <span class="mi">1728</span><span class="p">,</span> <span class="mi">1800</span><span class="p">,</span> <span class="mi">1875</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1944</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2025</span><span class="p">,</span>
                        <span class="mi">2048</span><span class="p">,</span> <span class="mi">2160</span><span class="p">,</span> <span class="mi">2187</span><span class="p">,</span> <span class="mi">2250</span><span class="p">,</span> <span class="mi">2304</span><span class="p">,</span> <span class="mi">2400</span><span class="p">,</span> <span class="mi">2430</span><span class="p">,</span> <span class="mi">2500</span><span class="p">,</span> <span class="mi">2560</span><span class="p">,</span> <span class="mi">2592</span><span class="p">,</span> <span class="mi">2700</span><span class="p">,</span>
                        <span class="mi">2880</span><span class="p">,</span> <span class="mi">2916</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">3072</span><span class="p">,</span> <span class="mi">3125</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">3240</span><span class="p">,</span> <span class="mi">3375</span><span class="p">,</span> <span class="mi">3456</span><span class="p">,</span> <span class="mi">3600</span><span class="p">,</span> <span class="mi">3645</span><span class="p">,</span>
                        <span class="mi">3750</span><span class="p">,</span> <span class="mi">3840</span><span class="p">,</span> <span class="mi">3888</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">4050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4320</span><span class="p">,</span> <span class="mi">4374</span><span class="p">,</span> <span class="mi">4500</span><span class="p">,</span> <span class="mi">4608</span><span class="p">,</span> <span class="mi">4800</span><span class="p">,</span>
                        <span class="mi">4860</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">5120</span><span class="p">,</span> <span class="mi">5184</span><span class="p">,</span> <span class="mi">5400</span><span class="p">,</span> <span class="mi">5625</span><span class="p">,</span> <span class="mi">5760</span><span class="p">,</span> <span class="mi">5832</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="mi">6075</span><span class="p">,</span> <span class="mi">6144</span><span class="p">,</span>
                        <span class="mi">6250</span><span class="p">,</span> <span class="mi">6400</span><span class="p">,</span> <span class="mi">6480</span><span class="p">,</span> <span class="mi">6561</span><span class="p">,</span> <span class="mi">6750</span><span class="p">,</span> <span class="mi">6912</span><span class="p">,</span> <span class="mi">7200</span><span class="p">,</span> <span class="mi">7290</span><span class="p">,</span> <span class="mi">7500</span><span class="p">,</span> <span class="mi">7680</span><span class="p">,</span> <span class="mi">7776</span><span class="p">,</span>
                        <span class="mi">8000</span><span class="p">,</span> <span class="mi">8100</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span> <span class="mi">8640</span><span class="p">,</span> <span class="mi">8748</span><span class="p">,</span> <span class="mi">9000</span><span class="p">,</span> <span class="mi">9216</span><span class="p">,</span> <span class="mi">9375</span><span class="p">,</span> <span class="mi">9600</span><span class="p">,</span> <span class="mi">9720</span><span class="p">,</span> <span class="mi">10000</span><span class="p">])</span>
<span class="n">_good_range</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">_good_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># Disabling doctests when scipy isn&#39;t present.</span>
<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">,):</span> <span class="p">[</span><span class="s1">&#39;scipy.fft&#39;</span><span class="p">]}</span>

<span class="n">BOUNDARY_OPTIONS</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_next_fast_lengths</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find optimal or good sizes to pad an array of ``shape`` to for better</span>
<span class="sd">    performance with `numpy.fft.*fft` and `scipy.fft.*fft`.</span>
<span class="sd">    Calculated directly with `scipy.fft.next_fast_len`, if available; otherwise</span>
<span class="sd">    looked up from list and scaled by powers of 10, if necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">scipy.fft</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span> <span class="o">-</span> <span class="n">_good_range</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">_good_sizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">newshape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No next fast length for </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> found in list of _good_sizes &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;&lt;= </span><span class="si">{</span><span class="n">_good_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newshape</span>


<span class="k">def</span> <span class="nf">_copy_input_if_needed</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">nan_treatment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Alias input</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">array</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">)</span> <span class="k">else</span> <span class="nb">input</span>
    <span class="c1"># strip quantity attributes</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">value</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span>
    <span class="c1"># Copy input</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Anything that&#39;s masked must be turned into NaNs for the interpolation.</span>
        <span class="c1"># This requires copying. A copy is also needed for nan_treatment == &#39;fill&#39;</span>
        <span class="c1"># A copy prevents possible function side-effects of the input array.</span>
        <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
                <span class="c1"># ``np.ma.maskedarray.filled()`` returns a copy, however there</span>
                <span class="c1"># is no way to specify the return type or order etc. In addition</span>
                <span class="c1"># ``np.nan`` is a ``float`` and there is no conversion to an</span>
                <span class="c1"># ``int`` type. Therefore, a pre-fill copy is needed for non</span>
                <span class="c1"># ``float`` masked arrays. ``subok=True`` is needed to retain</span>
                <span class="c1"># ``np.ma.maskedarray.filled()``. ``copy=False`` allows the fill</span>
                <span class="c1"># to act as the copy if type and order are already correct.</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Since we&#39;re making a copy, we might as well use `subok=False` to save,</span>
                <span class="c1"># what is probably, a negligible amount of memory.</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># mask != 0 yields a bool mask for all ints/floats/bool</span>
                <span class="n">output</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The call below is synonymous with np.asanyarray(array, ftype=float, order=&#39;C&#39;)</span>
            <span class="c1"># The advantage of `subok=True` is that it won&#39;t copy when array is an ndarray subclass. If it</span>
            <span class="c1"># is and `subok=False` (default), then it will copy even if `copy=False`. This uses less memory</span>
            <span class="c1"># when ndarray subclasses are passed in.</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input should be a Numpy array or something &#39;</span>
                        <span class="s1">&#39;convertible into a float array&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>


<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../fermi_stacking.html#fermi_stacking.fermi_stacking_module.convolve">[docs]</a><span class="nd">@support_nddata</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">preserve_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalization_zero_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an array with a kernel.</span>

<span class="sd">    This routine differs from `scipy.ndimage.convolve` because</span>
<span class="sd">    it includes a special treatment for ``NaN`` values. Rather than</span>
<span class="sd">    including ``NaN`` values in the array in the convolution calculation, which</span>
<span class="sd">    causes large ``NaN`` holes in the convolved array, ``NaN`` values are</span>
<span class="sd">    replaced with interpolated values using the kernel as an interpolation</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `~astropy.nddata.NDData` or array-like</span>
<span class="sd">        The array to convolve. This should be a 1, 2, or 3-dimensional array</span>
<span class="sd">        or a list or a set of nested lists representing a 1, 2, or</span>
<span class="sd">        3-dimensional array.  If an `~astropy.nddata.NDData`, the ``mask`` of</span>
<span class="sd">        the `~astropy.nddata.NDData` will be used as the ``mask`` argument.</span>
<span class="sd">    kernel : `numpy.ndarray` or `~astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those for</span>
<span class="sd">        the array, and the dimensions should be odd in all directions.  If a</span>
<span class="sd">        masked array, the masked values will be replaced by ``fill_value``.</span>
<span class="sd">    boundary : str, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>
<span class="sd">            * `None`</span>
<span class="sd">                Set the ``result`` values to zero where the kernel</span>
<span class="sd">                extends beyond the edge of the array.</span>
<span class="sd">            * &#39;fill&#39;</span>
<span class="sd">                Set values outside the array boundary to ``fill_value`` (default).</span>
<span class="sd">            * &#39;wrap&#39;</span>
<span class="sd">                Periodic boundary that wrap to the other side of ``array``.</span>
<span class="sd">            * &#39;extend&#39;</span>
<span class="sd">                Set values outside the array to the nearest ``array``</span>
<span class="sd">                value.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using ``boundary=&#39;fill&#39;``.</span>
<span class="sd">    normalize_kernel : bool, optional</span>
<span class="sd">        Whether to normalize the kernel to have a sum of one.</span>
<span class="sd">    nan_treatment : {&#39;interpolate&#39;, &#39;fill&#39;}, optional</span>
<span class="sd">        The method used to handle NaNs in the input ``array``:</span>
<span class="sd">            * ``&#39;interpolate&#39;``: ``NaN`` values are replaced with</span>
<span class="sd">              interpolated values using the kernel as an interpolation</span>
<span class="sd">              function. Note that if the kernel has a sum equal to</span>
<span class="sd">              zero, NaN interpolation is not possible and will raise an</span>
<span class="sd">              exception.</span>
<span class="sd">            * ``&#39;fill&#39;``: ``NaN`` values are replaced by ``fill_value``</span>
<span class="sd">              prior to convolution.</span>
<span class="sd">    preserve_nan : bool, optional</span>
<span class="sd">        After performing convolution, should pixels that were originally NaN</span>
<span class="sd">        again become NaN?</span>
<span class="sd">    mask : None or ndarray, optional</span>
<span class="sd">        A &quot;mask&quot; array.  Shape must match ``array``, and anything that is masked</span>
<span class="sd">        (i.e., not 0/`False`) will be set to NaN for the convolution.  If</span>
<span class="sd">        `None`, no masking will be performed unless ``array`` is a masked array.</span>
<span class="sd">        If ``mask`` is not `None` *and* ``array`` is a masked array, a pixel is</span>
<span class="sd">        masked of it is masked in either ``mask`` *or* ``array.mask``.</span>
<span class="sd">    normalization_zero_tol : float, optional</span>
<span class="sd">        The absolute tolerance on whether the kernel is different than zero.</span>
<span class="sd">        If the kernel sums to zero to within this precision, it cannot be</span>
<span class="sd">        normalized. Default is &quot;1e-8&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : `numpy.ndarray`</span>
<span class="sd">        An array with the same dimensions and as the input array,</span>
<span class="sd">        convolved with kernel.  The data type depends on the input</span>
<span class="sd">        array type.  If array is a floating point type, then the</span>
<span class="sd">        return array keeps the same data type, otherwise the type</span>
<span class="sd">        is ``numpy.float``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For masked arrays, masked values are treated as NaNs.  The convolution</span>
<span class="sd">    is always done at ``numpy.float`` precision.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">BOUNDARY_OPTIONS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid boundary option: must be one of </span><span class="si">{</span><span class="n">BOUNDARY_OPTIONS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nan_treatment must be one of &#39;interpolate&#39;,&#39;fill&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># OpenMP support is disabled at the C src code level, changing this will have</span>
    <span class="c1"># no effect.</span>
    <span class="n">n_threads</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Keep refs to originals</span>
    <span class="n">passed_kernel</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="n">passed_array</span> <span class="o">=</span> <span class="n">array</span>

    <span class="c1"># The C routines all need float type inputs (so, a particular</span>
    <span class="c1"># bit size, endianness, etc.).  So we have to convert, which also</span>
    <span class="c1"># has the effect of making copies so we don&#39;t modify the inputs.</span>
    <span class="c1"># After this, the variables we work with will be array_internal, and</span>
    <span class="c1"># kernel_internal.  However -- we do want to keep track of what type</span>
    <span class="c1"># the input array was so we can cast the result to that at the end</span>
    <span class="c1"># if it&#39;s a floating point type.  Don&#39;t bother with this for lists --</span>
    <span class="c1"># just always push those as float.</span>
    <span class="c1"># It is always necessary to make a copy of kernel (since it is modified),</span>
    <span class="c1"># but, if we just so happen to be lucky enough to have the input array</span>
    <span class="c1"># have exactly the desired type, we just alias to array_internal</span>
    <span class="c1"># Convert kernel to ndarray if not already</span>

    <span class="c1"># Copy or alias array to array_internal</span>
    <span class="n">array_internal</span> <span class="o">=</span> <span class="n">_copy_input_if_needed</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                                           <span class="n">nan_treatment</span><span class="o">=</span><span class="n">nan_treatment</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                           <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">array_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Copy or alias kernel to kernel_internal</span>
    <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">_copy_input_if_needed</span><span class="p">(</span><span class="n">passed_kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                                            <span class="n">nan_treatment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># Make sure kernel has all odd axes</span>
    <span class="k">if</span> <span class="n">has_even_axis</span><span class="p">(</span><span class="n">kernel_internal</span><span class="p">):</span>
        <span class="n">raise_even_kernel_exception</span><span class="p">()</span>

    <span class="c1"># If both image array and kernel are Kernel instances</span>
    <span class="c1"># constrain convolution method</span>
    <span class="c1"># This must occur before the main alias/copy of ``passed_kernel`` to</span>
    <span class="c1"># ``kernel_internal`` as it is used for filling masked kernels.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Both array and kernel are Kernel instances, hardwiring &quot;</span>
                      <span class="s2">&quot;the following parameters: boundary=&#39;fill&#39;, fill_value=0,&quot;</span>
                      <span class="s2">&quot; normalize_Kernel=True, nan_treatment=&#39;interpolate&#39;&quot;</span><span class="p">,</span>
                      <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="s1">&#39;fill&#39;</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">normalize_kernel</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nan_treatment</span> <span class="o">=</span> <span class="s1">&#39;interpolate&#39;</span>

    <span class="c1"># -----------------------------------------------------------------------</span>
    <span class="c1"># From this point onwards refer only to ``array_internal`` and</span>
    <span class="c1"># ``kernel_internal``.</span>
    <span class="c1"># Assume both are base np.ndarrays and NOT subclasses e.g. NOT</span>
    <span class="c1"># ``Kernel`` nor ``np.ma.maskedarray`` classes.</span>
    <span class="c1"># -----------------------------------------------------------------------</span>

    <span class="c1"># Check dimensionality</span>
    <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot convolve 0-dimensional arrays&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;convolve only supports 1, 2, and 3-dimensional &#39;</span>
                                  <span class="s1">&#39;arrays at this time&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;array and kernel have differing number of &#39;</span>
                        <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>

    <span class="n">array_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_internal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">kernel_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel_internal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="n">kernel_shape</span><span class="o">//</span><span class="mi">2</span>

    <span class="c1"># For boundary=None only the center space is convolved. All array indices within a</span>
    <span class="c1"># distance kernel.shape//2 from the edge are completely ignored (zeroed).</span>
    <span class="c1"># E.g. (1D list) only the indices len(kernel)//2 : len(array)-len(kernel)//2</span>
    <span class="c1"># are convolved. It is therefore not possible to use this method to convolve an</span>
    <span class="c1"># array by a kernel that is larger (see note below) than the array - as ALL pixels would be ignored</span>
    <span class="c1"># leaving an array of only zeros.</span>
    <span class="c1"># Note: For even kernels the correctness condition is array_shape &gt; kernel_shape.</span>
    <span class="c1"># For odd kernels it is:</span>
    <span class="c1"># array_shape &gt;= kernel_shape OR array_shape &gt; kernel_shape-1 OR array_shape &gt; 2*(kernel_shape//2).</span>
    <span class="c1"># Since the latter is equal to the former two for even lengths, the latter condition is complete.</span>
    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">array_shape</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad_width</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">KernelSizeError</span><span class="p">(</span><span class="s2">&quot;for boundary=None all kernel axes must be smaller than array&#39;s - &quot;</span>
                              <span class="s2">&quot;use boundary in [&#39;fill&#39;, &#39;extend&#39;, &#39;wrap&#39;] instead.&quot;</span><span class="p">)</span>

    <span class="c1"># NaN interpolation significantly slows down the C convolution</span>
    <span class="c1"># computation. Since nan_treatment = &#39;interpolate&#39;, is the default</span>
    <span class="c1"># check whether it is even needed, if not, don&#39;t interpolate.</span>
    <span class="c1"># NB: np.isnan(array_internal.sum()) is faster than np.isnan(array_internal).any()</span>
    <span class="n">nan_interpolate</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array_internal</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="c1"># Check if kernel is normalizable</span>
    <span class="k">if</span> <span class="n">normalize_kernel</span> <span class="ow">or</span> <span class="n">nan_interpolate</span><span class="p">:</span>
        <span class="n">kernel_sum</span> <span class="o">=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">kernel_sums_to_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">kernel_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                         <span class="n">atol</span><span class="o">=</span><span class="n">normalization_zero_tol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kernel_sum</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span> <span class="ow">or</span> <span class="n">kernel_sums_to_zero</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nan_interpolate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Setting nan_treatment=&#39;interpolate&#39; &quot;</span>
                                 <span class="s2">&quot;requires the kernel to be normalized, &quot;</span>
                                 <span class="s2">&quot;but the input kernel has a sum close &quot;</span>
                                 <span class="s2">&quot;to zero. For a zero-sum kernel and &quot;</span>
                                 <span class="s2">&quot;data with NaNs, set nan_treatment=&#39;fill&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The kernel can&#39;t be normalized, because &quot;</span>
                                 <span class="s2">&quot;its sum is close to zero. The sum of the &quot;</span>
                                 <span class="s2">&quot;given kernel is &lt; </span><span class="si">{}</span><span class="s2">&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>

    <span class="c1"># Mark the NaN values so we can replace them later if interpolate_nan is</span>
    <span class="c1"># not set</span>
    <span class="k">if</span> <span class="n">preserve_nan</span> <span class="ow">or</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="n">initially_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array_internal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">array_internal</span><span class="p">[</span><span class="n">initially_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="c1"># Avoid any memory allocation within the C code. Allocate output array</span>
    <span class="c1"># here and pass through instead.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array_internal</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="n">embed_result_within_padded_region</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">array_to_convolve</span> <span class="o">=</span> <span class="n">array_internal</span>
    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">):</span>
        <span class="n">embed_result_within_padded_region</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
            <span class="c1"># This method is faster than using numpy.pad(..., mode=&#39;constant&#39;)</span>
            <span class="n">array_to_convolve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array_shape</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="c1"># Use bounds [pad_width[0]:array_shape[0]+pad_width[0]] instead of [pad_width[0]:-pad_width[0]]</span>
            <span class="c1"># to account for when the kernel has size of 1 making pad_width = 0.</span>
            <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">array_to_convolve</span><span class="p">[</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array_internal</span>
            <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">array_to_convolve</span><span class="p">[</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array_internal</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array_to_convolve</span><span class="p">[</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">pad_width</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array_internal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np_pad_mode_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span> <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="s1">&#39;wrap&#39;</span><span class="p">}</span>
            <span class="n">np_pad_mode</span> <span class="o">=</span> <span class="n">np_pad_mode_dict</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span>
            <span class="n">pad_width</span> <span class="o">=</span> <span class="n">kernel_shape</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">np_pad_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
            <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">np_pad_width</span> <span class="o">=</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np_pad_width</span> <span class="o">=</span> <span class="p">((</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">2</span><span class="p">],))</span>

            <span class="n">array_to_convolve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">np_pad_width</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">np_pad_mode</span><span class="p">)</span>

    <span class="n">_convolveNd_c</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">array_to_convolve</span><span class="p">,</span>
                  <span class="n">array_to_convolve</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_to_convolve</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span>
                  <span class="n">kernel_internal</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span>
                  <span class="n">nan_interpolate</span><span class="p">,</span> <span class="n">embed_result_within_padded_region</span><span class="p">,</span>
                  <span class="n">n_threads</span><span class="p">)</span>

    <span class="c1"># So far, normalization has only occurred for nan_treatment == &#39;interpolate&#39;</span>
    <span class="c1"># because this had to happen within the C extension so as to ignore</span>
    <span class="c1"># any NaNs</span>
    <span class="k">if</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nan_interpolate</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">kernel_sum</span>
    <span class="k">elif</span> <span class="n">nan_interpolate</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">kernel_sum</span>

    <span class="k">if</span> <span class="n">nan_interpolate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">preserve_nan</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">sum</span><span class="p">()):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;nan_treatment=&#39;interpolate&#39;, however, NaN values detected &quot;</span>
                      <span class="s2">&quot;post convolution. A contiguous region of NaN values, larger &quot;</span>
                      <span class="s2">&quot;than the kernel size, are present in the input array. &quot;</span>
                      <span class="s2">&quot;Increase the kernel size to avoid this.&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_nan</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">initially_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Convert result to original data type</span>
    <span class="n">array_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">array_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">&lt;&lt;=</span> <span class="n">array_unit</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">):</span>
            <span class="n">new_result</span> <span class="o">=</span> <span class="n">Kernel1D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_array</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">):</span>
            <span class="n">new_result</span> <span class="o">=</span> <span class="n">Kernel2D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 1D and 2D Kernels are supported.&quot;</span><span class="p">)</span>
        <span class="n">new_result</span><span class="o">.</span><span class="n">_is_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">new_result</span><span class="o">.</span><span class="n">_separable</span> <span class="o">=</span> <span class="n">passed_array</span><span class="o">.</span><span class="n">_separable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passed_kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="n">new_result</span><span class="o">.</span><span class="n">_separable</span> <span class="o">=</span> <span class="n">new_result</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">and</span> <span class="n">passed_kernel</span><span class="o">.</span><span class="n">_separable</span>
        <span class="k">return</span> <span class="n">new_result</span>
    <span class="k">elif</span> <span class="n">array_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="c1"># Try to preserve the input type if it&#39;s a floating point type</span>
        <span class="c1"># Avoid making another copy if possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@support_nddata</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convolve_fft</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">normalization_zero_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
                 <span class="n">preserve_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_fft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fft_pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_wt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">allow_huge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span>
                 <span class="n">complex_dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">dealias</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an ndarray with an nd-kernel.  Returns a convolved image with</span>
<span class="sd">    ``shape = array.shape``.  Assumes kernel is centered.</span>

<span class="sd">    `convolve_fft` is very similar to `convolve` in that it replaces ``NaN``</span>
<span class="sd">    values in the original image with interpolated values using the kernel as</span>
<span class="sd">    an interpolation function.  However, it also includes many additional</span>
<span class="sd">    options specific to the implementation.</span>

<span class="sd">    `convolve_fft` differs from `scipy.signal.fftconvolve` in a few ways:</span>

<span class="sd">    * It can treat ``NaN`` values as zeros or interpolate over them.</span>
<span class="sd">    * ``inf`` values are treated as ``NaN``</span>
<span class="sd">    * It optionally pads to the nearest faster sizes to improve FFT speed.</span>
<span class="sd">      These sizes are optimized for the numpy and scipy implementations, and</span>
<span class="sd">      ``fftconvolve`` uses them by default as well; when using other external</span>
<span class="sd">      functions (see below), results may vary.</span>
<span class="sd">    * Its only valid ``mode`` is &#39;same&#39; (i.e., the same shape array is returned)</span>
<span class="sd">    * It lets you use your own fft, e.g.,</span>
<span class="sd">      `pyFFTW &lt;https://pypi.org/project/pyFFTW/&gt;`_ or</span>
<span class="sd">      `pyFFTW3 &lt;https://pypi.org/project/PyFFTW3/0.2.1/&gt;`_ , which can lead to</span>
<span class="sd">      performance improvements, depending on your system configuration.  pyFFTW3</span>
<span class="sd">      is threaded, and therefore may yield significant performance benefits on</span>
<span class="sd">      multi-core machines at the cost of greater memory requirements.  Specify</span>
<span class="sd">      the ``fftn`` and ``ifftn`` keywords to override the default, which is</span>
<span class="sd">      `numpy.fft.fftn` and `numpy.fft.ifftn`.  The `scipy.fft` functions also</span>
<span class="sd">      offer somewhat better performance and a multi-threaded option.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        Array to be convolved with ``kernel``.  It can be of any</span>
<span class="sd">        dimensionality, though only 1, 2, and 3d arrays have been tested.</span>
<span class="sd">    kernel : `numpy.ndarray` or `astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array.  The dimensions *do not* have to be odd in all directions,</span>
<span class="sd">        unlike in the non-fft `convolve` function.  The kernel will be</span>
<span class="sd">        normalized if ``normalize_kernel`` is set.  It is assumed to be centered</span>
<span class="sd">        (i.e., shifts may result if your kernel is asymmetric)</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">            * &#39;fill&#39;: set values outside the array boundary to fill_value</span>
<span class="sd">              (default)</span>
<span class="sd">            * &#39;wrap&#39;: periodic boundary</span>

<span class="sd">        The `None` and &#39;extend&#39; parameters are not supported for FFT-based</span>
<span class="sd">        convolution.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using boundary=&#39;fill&#39;.</span>
<span class="sd">    nan_treatment : {&#39;interpolate&#39;, &#39;fill&#39;}, optional</span>
<span class="sd">        The method used to handle NaNs in the input ``array``:</span>
<span class="sd">            * ``&#39;interpolate&#39;``: ``NaN`` values are replaced with</span>
<span class="sd">              interpolated values using the kernel as an interpolation</span>
<span class="sd">              function. Note that if the kernel has a sum equal to</span>
<span class="sd">              zero, NaN interpolation is not possible and will raise an</span>
<span class="sd">              exception.</span>
<span class="sd">            * ``&#39;fill&#39;``: ``NaN`` values are replaced by ``fill_value``</span>
<span class="sd">              prior to convolution.</span>
<span class="sd">    normalize_kernel : callable or boolean, optional</span>
<span class="sd">        If specified, this is the function to divide kernel by to normalize it.</span>
<span class="sd">        e.g., ``normalize_kernel=np.sum`` means that kernel will be modified to be:</span>
<span class="sd">        ``kernel = kernel / np.sum(kernel)``.  If True, defaults to</span>
<span class="sd">        ``normalize_kernel = np.sum``.</span>
<span class="sd">    normalization_zero_tol : float, optional</span>
<span class="sd">        The absolute tolerance on whether the kernel is different than zero.</span>
<span class="sd">        If the kernel sums to zero to within this precision, it cannot be</span>
<span class="sd">        normalized. Default is &quot;1e-8&quot;.</span>
<span class="sd">    preserve_nan : bool, optional</span>
<span class="sd">        After performing convolution, should pixels that were originally NaN</span>
<span class="sd">        again become NaN?</span>
<span class="sd">    mask : None or ndarray, optional</span>
<span class="sd">        A &quot;mask&quot; array.  Shape must match ``array``, and anything that is masked</span>
<span class="sd">        (i.e., not 0/`False`) will be set to NaN for the convolution.  If</span>
<span class="sd">        `None`, no masking will be performed unless ``array`` is a masked array.</span>
<span class="sd">        If ``mask`` is not `None` *and* ``array`` is a masked array, a pixel is</span>
<span class="sd">        masked of it is masked in either ``mask`` *or* ``array.mask``.</span>
<span class="sd">    crop : bool, optional</span>
<span class="sd">        Default on.  Return an image of the size of the larger of the input</span>
<span class="sd">        image and the kernel.</span>
<span class="sd">        If the image and kernel are asymmetric in opposite directions, will</span>
<span class="sd">        return the largest image in both directions.</span>
<span class="sd">        For example, if an input image has shape [100,3] but a kernel with shape</span>
<span class="sd">        [6,6] is used, the output will be [100,6].</span>
<span class="sd">    return_fft : bool, optional</span>
<span class="sd">        Return the ``fft(image)*fft(kernel)`` instead of the convolution (which is</span>
<span class="sd">        ``ifft(fft(image)*fft(kernel))``).  Useful for making PSDs.</span>
<span class="sd">    fft_pad : bool, optional</span>
<span class="sd">        Default on.  Zero-pad image to the nearest size supporting more efficient</span>
<span class="sd">        execution of the FFT, generally values factorizable into the first 3-5</span>
<span class="sd">        prime numbers.  With ``boundary=&#39;wrap&#39;``, this will be disabled.</span>
<span class="sd">    psf_pad : bool, optional</span>
<span class="sd">        Zero-pad image to be at least the sum of the image sizes to avoid</span>
<span class="sd">        edge-wrapping when smoothing.  This is enabled by default with</span>
<span class="sd">        ``boundary=&#39;fill&#39;``, but it can be overridden with a boolean option.</span>
<span class="sd">        ``boundary=&#39;wrap&#39;`` and ``psf_pad=True`` are not compatible.</span>
<span class="sd">    min_wt : float, optional</span>
<span class="sd">        If ignoring ``NaN`` / zeros, force all grid points with a weight less than</span>
<span class="sd">        this value to ``NaN`` (the weight of a grid point with *no* ignored</span>
<span class="sd">        neighbors is 1.0).</span>
<span class="sd">        If ``min_wt`` is zero, then all zero-weight points will be set to zero</span>
<span class="sd">        instead of ``NaN`` (which they would be otherwise, because 1/0 = nan).</span>
<span class="sd">        See the examples below.</span>
<span class="sd">    allow_huge : bool, optional</span>
<span class="sd">        Allow huge arrays in the FFT?  If False, will raise an exception if the</span>
<span class="sd">        array or kernel size is &gt;1 GB.</span>
<span class="sd">    fftn : callable, optional</span>
<span class="sd">        The fft function.  Can be overridden to use your own ffts,</span>
<span class="sd">        e.g. an fftw3 wrapper or scipy&#39;s fftn, ``fft=scipy.fftpack.fftn``.</span>
<span class="sd">    ifftn : callable, optional</span>
<span class="sd">        The inverse fft function. Can be overridden the same way ``fttn``.</span>
<span class="sd">    complex_dtype : complex type, optional</span>
<span class="sd">        Which complex dtype to use.  `numpy` has a range of options, from 64 to</span>
<span class="sd">        256.</span>
<span class="sd">    dealias: bool, optional</span>
<span class="sd">        Default off. Zero-pad image to enable explicit dealiasing</span>
<span class="sd">        of convolution. With ``boundary=&#39;wrap&#39;``, this will be disabled.</span>
<span class="sd">        Note that for an input of nd dimensions this will increase</span>
<span class="sd">        the size of the temporary arrays by at least ``1.5**nd``.</span>
<span class="sd">        This may result in significantly more memory usage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : ndarray</span>
<span class="sd">        ``array`` convolved with ``kernel``.  If ``return_fft`` is set, returns</span>
<span class="sd">        ``fft(array) * fft(kernel)``.  If crop is not set, returns the</span>
<span class="sd">        image, but with the fft-padded size instead of the input size.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `ValueError`</span>
<span class="sd">        If the array is bigger than 1 GB after padding, will raise this</span>
<span class="sd">        exception unless ``allow_huge`` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve:</span>
<span class="sd">        Convolve is a non-fft version of this code.  It is more memory</span>
<span class="sd">        efficient and for small kernels can be faster.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    With ``psf_pad=True`` and a large PSF, the resulting data</span>
<span class="sd">    can become large and consume a lot of memory. See Issue</span>
<span class="sd">    https://github.com/astropy/astropy/pull/4366 and the update in</span>
<span class="sd">    https://github.com/astropy/astropy/pull/11533 for further details.</span>

<span class="sd">    Dealiasing of pseudospectral convolutions is necessary for</span>
<span class="sd">    numerical stability of the underlying algorithms. A common</span>
<span class="sd">    method for handling this is to zero pad the image by at least</span>
<span class="sd">    1/2 to eliminate the wavenumbers which have been aliased</span>
<span class="sd">    by convolution. This is so that the aliased 1/3 of the</span>
<span class="sd">    results of the convolution computation can be thrown out. See</span>
<span class="sd">    https://doi.org/10.1175/1520-0469(1971)028%3C1074:OTEOAI%3E2.0.CO;2</span>
<span class="sd">    https://iopscience.iop.org/article/10.1088/1742-6596/318/7/072037</span>

<span class="sd">    Note that if dealiasing is necessary to your application, but your</span>
<span class="sd">    process is memory constrained, you may want to consider using</span>
<span class="sd">    FFTW++: https://github.com/dealias/fftwpp. It includes python</span>
<span class="sd">    wrappers for a pseudospectral convolution which will implicitly</span>
<span class="sd">    dealias your convolution without the need for additional padding.</span>
<span class="sd">    Note that one cannot use FFTW++&#39;s convlution directly in this</span>
<span class="sd">    method as in handles the entire convolution process internally.</span>
<span class="sd">    Additionally, FFTW++ includes other useful pseudospectral methods to</span>
<span class="sd">    consider.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [1, 1, 1])</span>
<span class="sd">    array([0.33333333, 1.33333333, 1.        ])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1])</span>
<span class="sd">    array([0.5, 2. , 1.5])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [0, 1, 0])  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([ 1.00000000e+00, -3.70074342e-17,  3.00000000e+00])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 2, 3], [1])</span>
<span class="sd">    array([1., 2., 3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], nan_treatment=&#39;interpolate&#39;)</span>
<span class="sd">    array([1., 0., 3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...              min_wt=1e-8)</span>
<span class="sd">    array([ 1., nan,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;)</span>
<span class="sd">    array([0.5, 2. , 1.5])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...               normalize_kernel=True)</span>
<span class="sd">    array([0.5, 2. , 1.5])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.fft  # optional - requires scipy</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...               normalize_kernel=True,</span>
<span class="sd">    ...               fftn=scipy.fft.fftn, ifftn=scipy.fft.ifftn)</span>
<span class="sd">    array([0.5, 2. , 1.5])</span>

<span class="sd">    &gt;&gt;&gt; fft_mp = lambda a: scipy.fft.fftn(a, workers=-1)  # use all available cores</span>
<span class="sd">    &gt;&gt;&gt; ifft_mp = lambda a: scipy.fft.ifftn(a, workers=-1)</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...               normalize_kernel=True, fftn=fft_mp, ifftn=ifft_mp)</span>
<span class="sd">    array([0.5, 2. , 1.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Checking copied from convolve.py - however, since FFTs have real &amp;</span>
    <span class="c1"># complex components, we change the types.  Only the real part will be</span>
    <span class="c1"># returned! Note that this always makes a copy.</span>

    <span class="c1"># Check kernel is kernel instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t convolve two kernels with convolve_fft.  Use convolve instead.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nan_treatment must be one of &#39;interpolate&#39;,&#39;fill&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Get array quantity if it exists</span>
    <span class="n">array_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Convert array dtype to complex</span>
    <span class="c1"># and ensure that list inputs become arrays</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">_copy_input_if_needed</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                                  <span class="n">nan_treatment</span><span class="o">=</span><span class="n">nan_treatment</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                  <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">_copy_input_if_needed</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                                   <span class="n">nan_treatment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image and kernel must have same number of dimensions&quot;</span><span class="p">)</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">kernshape</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">array_size_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_B</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size Error: Arrays will be </span><span class="si">{</span><span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_B</span><span class="p">)</span><span class="si">}</span><span class="s2">.  &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;Use allow_huge=True to override this exception.&quot;</span><span class="p">)</span>

    <span class="c1"># NaN and inf catching</span>
    <span class="n">nanmaskarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nanmaskkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">normalize_kernel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The kernel can&#39;t be normalized, because its sum is &quot;</span>
                            <span class="s2">&quot;close to zero. The sum of the given kernel is &lt; </span><span class="si">{}</span><span class="s2">&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if we want to normalize it, leave it normed!</span>
    <span class="k">elif</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="c1"># try this.  If a function is not passed, the code will just crash... I</span>
        <span class="c1"># think type checking would be better but PEPs say otherwise...</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">normalize_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel_scale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">normalization_zero_tol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot interpolate NaNs with an unnormalizable kernel&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the kernel&#39;s sum is near-zero, so it can&#39;t be scaled</span>
                <span class="n">kernel_scale</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the kernel is normalizable; we&#39;ll temporarily normalize it</span>
            <span class="c1"># now and undo the normalization later.</span>
            <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The convolve_fft version of boundary=None is &quot;</span>
                      <span class="s2">&quot;equivalent to the convolve boundary=&#39;fill&#39;.  There is &quot;</span>
                      <span class="s2">&quot;no FFT equivalent to convolve&#39;s &quot;</span>
                      <span class="s2">&quot;zero-if-kernel-leaves-boundary&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="c1"># create a boundary region at least as large as the kernel</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;psf_pad was set to </span><span class="si">{</span><span class="n">psf_pad</span><span class="si">}</span><span class="s2">, which overrides the &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;boundary=&#39;fill&#39; setting.&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default is &#39;True&#39; according to the docstring</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With boundary=&#39;wrap&#39;, psf_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With boundary=&#39;wrap&#39;, fft_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">dealias</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With boundary=&#39;wrap&#39;, dealias cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># force zero; it should not be used</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;extend&#39; option is not implemented &quot;</span>
                                  <span class="s2">&quot;for fft-based convolution&quot;</span><span class="p">)</span>

    <span class="c1"># Add shapes elementwise for psf_pad.</span>
    <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>  <span class="c1"># default=False</span>
        <span class="c1"># add the sizes along each dimension (bigger)</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># take the larger shape in each dimension (smaller)</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dealias</span><span class="p">:</span>
        <span class="c1"># Extend shape by 1/2 for dealiasing</span>
        <span class="n">newshape</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">newshape</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Find ideal size for fft (was power of 2, now any powers of prime factors 2, 3, 5).</span>
    <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>  <span class="c1"># default=True</span>
        <span class="c1"># Get optimized sizes from scipy.</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">_next_fast_lengths</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span>

    <span class="c1"># perform a second check after padding</span>
    <span class="n">array_size_C</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_C</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size Error: Arrays will be </span><span class="si">{</span><span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_C</span><span class="p">)</span><span class="si">}</span><span class="s2">.  &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;Use allow_huge=True to override this exception.&quot;</span><span class="p">)</span>

    <span class="c1"># For future reference, this can be used to predict &quot;almost exactly&quot;</span>
    <span class="c1"># how much *additional* memory will be used.</span>
    <span class="c1"># size * (array + kernel + kernelfft + arrayfft +</span>
    <span class="c1">#         (kernel*array)fft +</span>
    <span class="c1">#         optional(weight image + weight_fft + weight_ifft) +</span>
    <span class="c1">#         optional(returned_fft))</span>
    <span class="c1"># total_memory_used_GB = (np.product(newshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c1">#                        * (5 + 3*((interpolate_nan or ) and kernel_is_normalized))</span>
    <span class="c1">#                        + (1 + (not return_fft)) *</span>
    <span class="c1">#                          np.product(arrayshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c1">#                        + np.product(arrayshape)*np.dtype(bool).itemsize</span>
    <span class="c1">#                        + np.product(kernshape)*np.dtype(bool).itemsize)</span>
    <span class="c1">#                        ) / 1024.**3</span>

    <span class="c1"># separate each dimension by the padding size...  this is to determine the</span>
    <span class="c1"># appropriate slice size to get back to the input dimensions</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">newdimsize</span><span class="p">,</span> <span class="n">arraydimsize</span><span class="p">,</span> <span class="n">kerndimsize</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">newdimsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">newdimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">arrayslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">arraydimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">arraydimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kernslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kerndimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">kerndimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arrayslices</span><span class="p">)</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kernslices</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">arrayshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigarray</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">kernshape</span><span class="p">):</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigkernel</span><span class="p">[</span><span class="n">kernslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">normalized_kernel</span>

    <span class="n">arrayfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigarray</span><span class="p">)</span>
    <span class="c1"># need to shift the kernel so that, e.g., [0,0,1,0] -&gt; [1,0,0,0] = unity</span>
    <span class="n">kernfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">bigkernel</span><span class="p">))</span>
    <span class="n">fftmult</span> <span class="o">=</span> <span class="n">arrayfft</span> <span class="o">*</span> <span class="n">kernfft</span>

    <span class="n">interpolate_nan</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interpolate_nan</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>

        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">nanmaskarray</span> <span class="o">*</span> <span class="n">interpolate_nan</span>
        <span class="n">wtfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">)</span>

        <span class="c1"># You can only get to this point if kernel_is_normalized</span>
        <span class="n">wtfftmult</span> <span class="o">=</span> <span class="n">wtfft</span> <span class="o">*</span> <span class="n">kernfft</span>
        <span class="n">wtsm</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">wtfftmult</span><span class="p">)</span>
        <span class="c1"># need to re-zero weights outside of the image (if it is padded, we</span>
        <span class="c1"># still don&#39;t weight those regions)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">wtsm</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigimwt</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># this check should be unnecessary; call it an insanity check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Encountered NaNs in convolve.  This is disallowed.&quot;</span><span class="p">)</span>

    <span class="n">fftmult</span> <span class="o">*=</span> <span class="n">kernel_scale</span>

    <span class="k">if</span> <span class="n">array_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fftmult</span> <span class="o">&lt;&lt;=</span> <span class="n">array_unit</span>

    <span class="k">if</span> <span class="n">return_fft</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftmult</span>

    <span class="k">if</span> <span class="n">interpolate_nan</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="c1"># divide by zeros are expected here; if the weight is zero, we want</span>
            <span class="c1"># the output to be nan or inf</span>
            <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span> <span class="o">/</span> <span class="n">bigimwt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">min_wt</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="n">min_wt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set anything with no weight to zero (taking into account</span>
                <span class="c1"># slight offsets due to floating-point errors).</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">bigimwt</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_nan</span><span class="p">:</span>
        <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">][</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rifft</span><span class="o">.</span><span class="n">real</span>


<span class="k">def</span> <span class="nf">interpolate_replace_nans</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">convolve</span><span class="o">=</span><span class="n">convolve</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a data set containing NaNs, replace the NaNs by interpolating from</span>
<span class="sd">    neighboring data points with a given kernel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        Array to be convolved with ``kernel``.  It can be of any</span>
<span class="sd">        dimensionality, though only 1, 2, and 3d arrays have been tested.</span>
<span class="sd">    kernel : `numpy.ndarray` or `astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array.  The dimensions *do not* have to be odd in all directions,</span>
<span class="sd">        unlike in the non-fft `convolve` function.  The kernel will be</span>
<span class="sd">        normalized if ``normalize_kernel`` is set.  It is assumed to be centered</span>
<span class="sd">        (i.e., shifts may result if your kernel is asymmetric).  The kernel</span>
<span class="sd">        *must be normalizable* (i.e., its sum cannot be zero).</span>
<span class="sd">    convolve : `convolve` or `convolve_fft`</span>
<span class="sd">        One of the two convolution functions defined in this package.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newarray : `numpy.ndarray`</span>
<span class="sd">        A copy of the original array with NaN pixels replaced with their</span>
<span class="sd">        interpolated counterparts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">newarray</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">convolved</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span>
                         <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">isnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">newarray</span><span class="p">[</span><span class="n">isnan</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolved</span><span class="p">[</span><span class="n">isnan</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">newarray</span>


<span class="k">def</span> <span class="nf">convolve_models</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two models using `~astropy.convolution.convolve_fft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `~astropy.modeling.core.Model`</span>
<span class="sd">        Functional model</span>
<span class="sd">    kernel : `~astropy.modeling.core.Model`</span>
<span class="sd">        Convolution kernel</span>
<span class="sd">    mode : str</span>
<span class="sd">        Keyword representing which function to use for convolution.</span>
<span class="sd">            * &#39;convolve_fft&#39; : use `~astropy.convolution.convolve_fft` function.</span>
<span class="sd">            * &#39;convolve&#39; : use `~astropy.convolution.convolve`.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Keyword arguments to me passed either to `~astropy.convolution.convolve`</span>
<span class="sd">        or `~astropy.convolution.convolve_fft` depending on ``mode``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : `~astropy.modeling.core.CompoundModel`</span>
<span class="sd">        Convolved model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;convolve_fft&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">SPECIAL_OPERATORS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">convolve_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;convolve&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">SPECIAL_OPERATORS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">convolve</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1"> is not supported.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">CompoundModel</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convolve_models_fft</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two models using `~astropy.convolution.convolve_fft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `~astropy.modeling.core.Model`</span>
<span class="sd">        Functional model</span>
<span class="sd">    kernel : `~astropy.modeling.core.Model`</span>
<span class="sd">        Convolution kernel</span>
<span class="sd">    bounding_box : tuple</span>
<span class="sd">        The bounding box which encompasses enough of the support of both</span>
<span class="sd">        the ``model`` and ``kernel`` so that an accurate convolution can be</span>
<span class="sd">        computed.</span>
<span class="sd">    resolution : float</span>
<span class="sd">        The resolution that one wishes to approximate the convolution</span>
<span class="sd">        integral at.</span>
<span class="sd">    cache : optional, bool</span>
<span class="sd">        Default value True. Allow for the storage of the convolution</span>
<span class="sd">        computation for later reuse.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Keyword arguments to be passed either to `~astropy.convolution.convolve`</span>
<span class="sd">        or `~astropy.convolution.convolve_fft` depending on ``mode``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : `~astropy.modeling.core.CompoundModel`</span>
<span class="sd">        Convolved model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">operator</span> <span class="o">=</span> <span class="n">SPECIAL_OPERATORS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">convolve_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Convolution</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">fermi_stacking</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../fermi_stacking.html">Fermi Stacking</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Chris Karwin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>