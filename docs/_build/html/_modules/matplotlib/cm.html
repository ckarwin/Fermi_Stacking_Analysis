
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>matplotlib.cm &#8212; fermi_stacking  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.cm</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Builtin colormaps, colormap handling utilities, and the `ScalarMappable` mixin.</span>

<span class="sd">.. seealso::</span>

<span class="sd">  :doc:`/gallery/color/colormap_reference` for a list of builtin colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to</span>
<span class="sd">  make colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormaps` an in-depth discussion of</span>
<span class="sd">  choosing colormaps.</span>

<span class="sd">  :doc:`/tutorials/colors/colormapnorms` for more details about data</span>
<span class="sd">  normalization.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">MutableMapping</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">_api</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib._cm</span> <span class="kn">import</span> <span class="n">datad</span>
<span class="kn">from</span> <span class="nn">matplotlib._cm_listed</span> <span class="kn">import</span> <span class="n">cmaps</span> <span class="k">as</span> <span class="n">cmaps_listed</span>


<span class="nd">@_api</span><span class="o">.</span><span class="n">caching_module_getattr</span>  <span class="c1"># module-level deprecations</span>
<span class="k">class</span> <span class="nc">__getattr__</span><span class="p">:</span>
    <span class="n">LUTSIZE</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">obj_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;rcParams[&#39;image.lut&#39;]&quot;</span><span class="p">)(</span>
            <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">_LUTSIZE</span><span class="p">))</span>


<span class="n">_LUTSIZE</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.lut&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_gen_cmap_registry</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dict mapping standard colormap names to standard colormaps, as</span>
<span class="sd">    well as the reversed colormaps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cmap_d</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">cmaps_listed</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">datad</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">cmap_d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># Precache the cmaps at a fixed lutsize..</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">_LUTSIZE</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;red&#39;</span> <span class="ow">in</span> <span class="n">spec</span> <span class="k">else</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s1">&#39;listed&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;listed&#39;</span> <span class="ow">in</span> <span class="n">spec</span> <span class="k">else</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">_LUTSIZE</span><span class="p">))</span>
    <span class="c1"># Generate reversed cmaps.</span>
    <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">cmap_d</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">reversed</span><span class="p">()</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">_global</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rmap</span><span class="o">.</span><span class="n">_global</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">cmap_d</span><span class="p">[</span><span class="n">rmap</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmap</span>
    <span class="k">return</span> <span class="n">cmap_d</span>


<span class="k">class</span> <span class="nc">_DeprecatedCmapDictWrapper</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dictionary mapping for deprecated _cmap_d access.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap_registry</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span> <span class="o">=</span> <span class="n">cmap_registry</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_deprecated</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmap_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_warn_deprecated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
            <span class="s2">&quot;3.3&quot;</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="s2">&quot;The global colormaps dictionary is no longer &quot;</span>
                    <span class="s2">&quot;considered public API.&quot;</span><span class="p">,</span>
            <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;Please use register_cmap() and get_cmap() to &quot;</span>
                        <span class="s2">&quot;access the contents of the dictionary.&quot;</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">ColormapRegistry</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for colormaps that are known to Matplotlib by name.</span>

<span class="sd">    .. admonition:: Experimental</span>

<span class="sd">       While we expect the API to be final, we formally mark it as</span>
<span class="sd">       experimental for 3.5 because we want to keep the option to still adapt</span>
<span class="sd">       the API for 3.6 should the need arise.</span>

<span class="sd">    The universal registry instance is `matplotlib.colormaps`. There should be</span>
<span class="sd">    no need for users to instantiate `.ColormapRegistry` themselves.</span>

<span class="sd">    Read access uses a dict-like interface mapping names to `.Colormap`\s::</span>

<span class="sd">        import matplotlib as mpl</span>
<span class="sd">        cmap = mpl.colormaps[&#39;viridis&#39;]</span>

<span class="sd">    Returned `.Colormap`\s are copies, so that their modification does not</span>
<span class="sd">    change the global definition of the colormap.</span>

<span class="sd">    Additional colormaps can be added via `.ColormapRegistry.register`::</span>

<span class="sd">        mpl.colormaps.register(my_colormap)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmaps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span> <span class="o">=</span> <span class="n">cmaps</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">!r}</span><span class="s2"> is not a known colormap name&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmaps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;ColormapRegistry; available colormaps:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the registered colormap names.</span>

<span class="sd">        This exists only for backward-compatibilty in `.pyplot` which had a</span>
<span class="sd">        ``plt.colormaps()`` method. The recommended way to get this list is</span>
<span class="sd">        now ``list(colormaps)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a new colormap.</span>

<span class="sd">        The colormap name can then be used as a string argument to any ``cmap``</span>
<span class="sd">        parameter in Matplotlib. It is also available in ``pyplot.get_cmap``.</span>

<span class="sd">        The colormap registry stores a copy of the given colormap, so that</span>
<span class="sd">        future changes to the original colormap instance do not affect the</span>
<span class="sd">        registered colormap. Think of this as the registry taking a snapshot</span>
<span class="sd">        of the colormap at registration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : matplotlib.colors.Colormap</span>
<span class="sd">            The colormap to register.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            The name for the colormap. If not given, ``cmap.name`` is used.</span>

<span class="sd">        force: bool, default: False</span>
<span class="sd">            If False, a ValueError is raised if trying to overwrite an already</span>
<span class="sd">            registered name. True supports overwriting registered colormaps</span>
<span class="sd">            other than the builtin colormaps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;A colormap named &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; is already registered.&#39;</span><span class="p">)</span>
        <span class="n">register_cmap</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>


<span class="n">_cmap_registry</span> <span class="o">=</span> <span class="n">_gen_cmap_registry</span><span class="p">()</span>
<span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_cmap_registry</span><span class="p">)</span>
<span class="c1"># This is no longer considered public API</span>
<span class="n">cmap_d</span> <span class="o">=</span> <span class="n">_DeprecatedCmapDictWrapper</span><span class="p">(</span><span class="n">_cmap_registry</span><span class="p">)</span>
<span class="n">__builtin_cmaps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_cmap_registry</span><span class="p">)</span>

<span class="c1"># public access to the colormaps should be via `matplotlib.colormaps`. For now,</span>
<span class="c1"># we still create the registry here, but that should stay an implementation</span>
<span class="c1"># detail.</span>
<span class="n">_colormaps</span> <span class="o">=</span> <span class="n">ColormapRegistry</span><span class="p">(</span><span class="n">_cmap_registry</span><span class="p">)</span>


<div class="viewcode-block" id="register_cmap"><a class="viewcode-back" href="../../fermi_stacking.html#fermi_stacking.fermi_stacking_module.register_cmap">[docs]</a><span class="k">def</span> <span class="nf">register_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">override_builtin</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a colormap to the set recognized by :func:`get_cmap`.</span>

<span class="sd">    Register a new colormap to be accessed by name ::</span>

<span class="sd">        LinearSegmentedColormap(&#39;swirly&#39;, data, lut)</span>
<span class="sd">        register_cmap(cmap=swirly_cmap)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">       The name that can be used in :func:`get_cmap` or :rc:`image.cmap`</span>

<span class="sd">       If absent, the name will be the :attr:`~matplotlib.colors.Colormap.name`</span>
<span class="sd">       attribute of the *cmap*.</span>

<span class="sd">    cmap : matplotlib.colors.Colormap</span>
<span class="sd">       Despite being the second argument and having a default value, this</span>
<span class="sd">       is a required argument.</span>

<span class="sd">    override_builtin : bool</span>

<span class="sd">        Allow built-in colormaps to be overridden by a user-supplied</span>
<span class="sd">        colormap.</span>

<span class="sd">        Please do not use this unless you are sure you need it.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Registering a colormap stores a reference to the colormap object</span>
<span class="sd">    which can currently be modified and inadvertently change the global</span>
<span class="sd">    colormap state. This behavior is deprecated and in Matplotlib 3.5</span>
<span class="sd">    the registered colormap will be immutable.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">((</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must include a name or a &quot;</span>
                             <span class="s2">&quot;Colormap&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_cmap_registry</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">override_builtin</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">__builtin_cmaps</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Trying to re-register the builtin cmap </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Trying to register the cmap </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> which already exists.&quot;</span>
            <span class="n">_api</span><span class="o">.</span><span class="n">warn_external</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must pass a Colormap instance. &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;You passed </span><span class="si">{</span><span class="n">cmap</span><span class="si">}</span><span class="s2"> a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span><span class="si">}</span><span class="s2"> object.&quot;</span><span class="p">)</span>

    <span class="n">cmap</span><span class="o">.</span><span class="n">_global</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_cmap_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span>
    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lut</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a colormap instance, defaulting to rc values if *name* is None.</span>

<span class="sd">    Colormaps added with :func:`register_cmap` take precedence over</span>
<span class="sd">    built-in colormaps.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Currently, this returns the global colormap object, which is deprecated.</span>
<span class="sd">    In Matplotlib 3.5, you will no longer be able to modify the global</span>
<span class="sd">    colormaps in-place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : `matplotlib.colors.Colormap` or str or None, default: None</span>
<span class="sd">        If a `.Colormap` instance, it will be returned. Otherwise, the name of</span>
<span class="sd">        a colormap known to Matplotlib, which will be resampled by *lut*. The</span>
<span class="sd">        default, None, means :rc:`image.cmap`.</span>
<span class="sd">    lut : int or None, default: None</span>
<span class="sd">        If *name* is not already a Colormap instance and *lut* is not None, the</span>
<span class="sd">        colormap will be resampled to have *lut* entries in the lookup table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.cmap&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">Colormap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="n">_api</span><span class="o">.</span><span class="n">check_in_list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_cmap_registry</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cmap_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cmap_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_resample</span><span class="p">(</span><span class="n">lut</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unregister_cmap</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove a colormap recognized by :func:`get_cmap`.</span>

<span class="sd">    You may not remove built-in colormaps.</span>

<span class="sd">    If the named colormap is not registered, returns with no error, raises</span>
<span class="sd">    if you try to de-register a default colormap.</span>

<span class="sd">    .. warning ::</span>

<span class="sd">      Colormap names are currently a shared namespace that may be used</span>
<span class="sd">      by multiple packages. Use `unregister_cmap` only if you know you</span>
<span class="sd">      have registered that name before. In particular, do not</span>
<span class="sd">      unregister just in case to clean the name before registering a</span>
<span class="sd">      new colormap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the colormap to be un-registered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ColorMap or None</span>
<span class="sd">        If the colormap was registered, return it if not return `None`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">       If you try to de-register a default built-in colormap.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cmap_registry</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">__builtin_cmaps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot unregister </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> which is a builtin &quot;</span>
                         <span class="s2">&quot;colormap.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_cmap_registry</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ScalarMappable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin class to map scalar data to RGBA.</span>

<span class="sd">    The ScalarMappable applies data normalization before returning RGBA colors</span>
<span class="sd">    from the given colormap.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : `matplotlib.colors.Normalize` (or subclass thereof)</span>
<span class="sd">            The normalizing object which scales data, typically into the</span>
<span class="sd">            interval ``[0, 1]``.</span>
<span class="sd">            If *None*, *norm* defaults to a *colors.Normalize* object which</span>
<span class="sd">            initializes its scaling based on the first data processed.</span>
<span class="sd">        cmap : str or `~matplotlib.colors.Colormap`</span>
<span class="sd">            The colormap used to map normalized data values to RGBA colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># So that the setter knows we&#39;re initializing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>  <span class="c1"># The Normalize instance of this ScalarMappable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># So that the setter knows we&#39;re initializing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>  <span class="c1"># The Colormap instance of this ScalarMappable.</span>
        <span class="c1">#: The last colorbar associated with this ScalarMappable. May be None.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorbar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">CallbackRegistry</span><span class="p">()</span>

    <span class="n">callbacksSM</span> <span class="o">=</span> <span class="n">_api</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.5&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;callbacks&quot;</span><span class="p">)(</span>
        <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_scale_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for initial scaling.</span>

<span class="sd">        Used by public functions that create a ScalarMappable and support</span>
<span class="sd">        parameters *vmin*, *vmax* and *norm*. This makes sure that a *norm*</span>
<span class="sd">        will take precedence over *vmin*, *vmax*.</span>

<span class="sd">        Note that this method does not set the norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Passing parameters norm and vmin/vmax simultaneously is &quot;</span>
                    <span class="s2">&quot;not supported. Please pass vmin/vmax directly to the &quot;</span>
                    <span class="s2">&quot;norm when creating it.&quot;</span><span class="p">)</span>

        <span class="c1"># always resolve the autoscaling so we have concrete limits</span>
        <span class="c1"># rather than deferring to draw time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a normalized rgba array corresponding to *x*.</span>

<span class="sd">        In the normal case, *x* is a 1D or 2D sequence of scalars, and</span>
<span class="sd">        the corresponding ndarray of rgba values will be returned,</span>
<span class="sd">        based on the norm and colormap set for this ScalarMappable.</span>

<span class="sd">        There is one special case, for handling images that are already</span>
<span class="sd">        rgb or rgba, such as might have been read from an image file.</span>
<span class="sd">        If *x* is an ndarray with 3 dimensions,</span>
<span class="sd">        and the last dimension is either 3 or 4, then it will be</span>
<span class="sd">        treated as an rgb or rgba array, and no mapping will be done.</span>
<span class="sd">        The array can be uint8, or it can be floating point with</span>
<span class="sd">        values in the 0-1 range; otherwise a ValueError will be raised.</span>
<span class="sd">        If it is a masked array, the mask will be ignored.</span>
<span class="sd">        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)</span>
<span class="sd">        will be used to fill in the transparency.  If the last dimension</span>
<span class="sd">        is 4, the *alpha* kwarg is ignored; it does not</span>
<span class="sd">        replace the pre-existing alpha.  A ValueError will be raised</span>
<span class="sd">        if the third dimension is other than 3 or 4.</span>

<span class="sd">        In either case, if *bytes* is *False* (default), the rgba</span>
<span class="sd">        array will be floats in the 0-1 range; if it is *True*,</span>
<span class="sd">        the returned rgba array will be uint8 in the 0 to 255 range.</span>

<span class="sd">        If norm is False, no normalization of the input data is</span>
<span class="sd">        performed, and it is assumed to be in the range (0-1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check for special case, image input:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>
                    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">xx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="n">xx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
                <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Third dimension must be 3 or 4&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">xx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Floating point image RGB values &quot;</span>
                                         <span class="s2">&quot;must be in the 0..1 range.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image RGB array must be uint8 or &quot;</span>
                                     <span class="s2">&quot;floating point; found </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">xx</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">xx</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># e.g., x is not an ndarray; so try mapping it</span>
            <span class="k">pass</span>

        <span class="c1"># This is the normal case, mapping a scalar array:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rgba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rgba</span>

    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value array from array-like *A*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : array-like or None</span>
<span class="sd">            The values that are mapped to colors.</span>

<span class="sd">            The base class `.ScalarMappable` does not make any assumptions on</span>
<span class="sd">            the dimensionality and shape of the value array *A*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_masked_invalid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image data of dtype </span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> cannot be &quot;</span>
                            <span class="s2">&quot;converted to float&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array of values, that are mapped to colors.</span>

<span class="sd">        The base class `.ScalarMappable` does not make any assumptions on</span>
<span class="sd">        the dimensionality and shape of the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>

    <span class="k">def</span> <span class="nf">get_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `.Colormap` instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span>

    <span class="k">def</span> <span class="nf">get_clim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the values (min, max) that are mapped to the colormap limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span>

    <span class="k">def</span> <span class="nf">set_clim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the norm limits for image scaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vmin, vmax : float</span>
<span class="sd">             The limits.</span>

<span class="sd">             The limits may also be passed as a tuple (*vmin*, *vmax*) as a</span>
<span class="sd">             single positional argument.</span>

<span class="sd">             .. ACCEPTS: (vmin: float, vmax: float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmin</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">_sanitize_extrema</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">_sanitize_extrema</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Always returns 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This method is intended to be overridden by Artist sub-classes</span>
        <span class="k">return</span> <span class="mf">1.</span>

    <span class="k">def</span> <span class="nf">set_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the colormap for luminance data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : `.Colormap` or str or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>  <span class="c1"># Things are not set up properly yet.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span>

    <span class="nd">@norm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="n">_api</span><span class="o">.</span><span class="n">check_isinstance</span><span class="p">((</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">:</span>
            <span class="c1"># We aren&#39;t updating anything</span>
            <span class="k">return</span>

        <span class="n">in_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="c1"># Remove the current callback and connect to the new one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the normalization instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : `.Normalize` or None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If there are any colorbars using the mappable for this norm, setting</span>
<span class="sd">        the norm of the mappable will reset the norm, locator, and formatters</span>
<span class="sd">        on the colorbar to default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>

    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoscale the scalar limits on the norm instance using the</span>
<span class="sd">        current array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must first set_array for mappable&#39;</span><span class="p">)</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">autoscale_None</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoscale the scalar limits on the norm instance using the</span>
<span class="sd">        current array, changing only limits that are None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must first set_array for mappable&#39;</span><span class="p">)</span>
        <span class="c1"># If the norm&#39;s limits are updated self.changed() will be called</span>
        <span class="c1"># through the callbacks attached to the norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call this whenever the mappable is changed to notify all the</span>
<span class="sd">        callbackSM listeners to the &#39;changed&#39; signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">fermi_stacking</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fermi_stacking.html">Fermi Stacking</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Chris Karwin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>